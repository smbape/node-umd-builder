From 9679543d1444f11606b3c4a4b3c50af85a724e2e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?St=C3=A9phane=20MBAPE?= <rose.martin-8og3raxw@yopmail.com>
Date: Sun, 3 Jan 2016 15:18:55 +0100
Subject: [PATCH] support comments in bower.json

---
 package.json                |   7 +-
 src/helpers.coffee          |   2 +-
 test/common.coffee          |   1 +
 test/remove_comments.coffee |  47 +++++++
 utils/read-components.js    | 327 ++++++++++++++++++++++++++++++++++++++++++++
 utils/remove-comments.js    |  56 ++++++++
 6 files changed, 436 insertions(+), 4 deletions(-)
 create mode 100644 test/remove_comments.coffee
 create mode 100644 utils/read-components.js
 create mode 100644 utils/remove-comments.js

diff --git a/package.json b/package.json
index a0b534f..34fb198 100644
--- a/package.json
+++ b/package.json
@@ -53,9 +53,10 @@
     "source-map": "~0.3.0"
   },
   "devDependencies": {
-    "mocha": "~1.12.0",
     "chai": "~1.7.0",
-    "rewire": "~1.1.3",
-    "express": "~3.3.0"
+    "express": "~3.3.0",
+    "lodash": "~3.10.1",
+    "mocha": "~1.12.0",
+    "rewire": "~1.1.3"
   }
 }
diff --git a/src/helpers.coffee b/src/helpers.coffee
index 238ba5f..c8316d6 100644
--- a/src/helpers.coffee
+++ b/src/helpers.coffee
@@ -6,7 +6,7 @@ os = require 'os'
 sysPath = require 'path'
 logger = require 'loggy'
 SourceNode = require('source-map').SourceNode
-readComponents = require 'read-components'
+readComponents = require '../utils/read-components'
 debug = require('debug')('brunch:helpers')
 commonRequireDefinition = require 'commonjs-require-definition'
 anymatch = require 'anymatch'
diff --git a/test/common.coffee b/test/common.coffee
index 6e3d98a..6cef691 100644
--- a/test/common.coffee
+++ b/test/common.coffee
@@ -1 +1,2 @@
 global.expect = require('chai').expect;
+global.assert = require('chai').assert
diff --git a/test/remove_comments.coffee b/test/remove_comments.coffee
new file mode 100644
index 0000000..83ae9fc
--- /dev/null
+++ b/test/remove_comments.coffee
@@ -0,0 +1,47 @@
+_ = require 'lodash'
+
+describe 'remove comments', ->
+    removeComments = require '../utils/remove-comments'
+
+    it 'should parse simple', ->
+        json = JSON.parse removeComments '{}'
+        assert.ok _.isEqual json, {}
+
+    it 'should parse simple line comment', ->
+        json = JSON.parse removeComments '{//comment\n}'
+        assert.ok _.isEqual json, {}
+
+        json = JSON.parse removeComments '//comment\n{}'
+        assert.ok _.isEqual json, {}
+
+        json = JSON.parse removeComments '{}//comment'
+        assert.ok _.isEqual json, {}
+
+        json = JSON.parse removeComments '{ "a": 1//comment\n}'
+        assert.ok _.isEqual json, {a : 1}
+
+        json = JSON.parse removeComments '{"a": 1//comment\n, "b": 2}'
+        assert.ok _.isEqual json, {a: 1, b: 2}
+
+    it 'should parse simple block comment', ->
+        json = JSON.parse removeComments '{/* comment */}'
+        assert.ok _.isEqual json, {}
+        
+        json = JSON.parse removeComments '/* comment */{}'
+        assert.ok _.isEqual json, {}
+
+        json = JSON.parse removeComments '{ "a": 1/* comment */}'
+        assert.ok _.isEqual json, {a : 1}
+
+        json = JSON.parse removeComments '{"a": 1/* comment */, "b": 2}'
+        assert.ok _.isEqual json, {a: 1, b: 2}
+
+    it 'should parse quote comment', ->
+        json = JSON.parse removeComments '{"a": ""/* //com"me/*n\nt*/}'
+        assert.ok _.isEqual json, {"a": ""}
+
+        json = JSON.parse removeComments '{"a": "//comment"}'
+        assert.ok _.isEqual json, {"a": "//comment"}
+
+        json = JSON.parse removeComments '{"a": "/* comment */"}'
+        assert.ok _.isEqual json, {"a": "/* comment */"}
diff --git a/utils/read-components.js b/utils/read-components.js
new file mode 100644
index 0000000..814ab6e
--- /dev/null
+++ b/utils/read-components.js
@@ -0,0 +1,327 @@
+/* jshint node: true */
+/* jshint curly: false */
+'use strict';
+
+/**
+ * Modified version of read-components to track custom properties
+ */
+
+var removeComments = require('./remove-comments');
+
+var sysPath = require('path');
+var fs = require('fs');
+var each = require('async-each');
+var events = require('events');
+var emitter = new events.EventEmitter();
+
+var jsonPaths = {
+    bower: 'bower.json',
+    dotbower: '.bower.json',
+    component: 'component.json'
+};
+
+var dependencyLocator = {
+    bower: 'name',
+    component: 'repo'
+};
+
+var componentBuilder = require('component-builder');
+var Builder = componentBuilder.Builder || componentBuilder;
+Builder.prototype.alias = function(a, b) {
+    var name = this.root ? this.config.name : this.basename;
+    var res = {};
+    res[name + '/' + b] = a;
+    emitter.emit('addAlias', res);
+    return 'require.alias("' + name + '/' + b + '", "' + a + '");';
+};
+
+var jsonProps = ['main', 'scripts', 'styles'];
+
+function getDir(root, type, callback) {
+    if (type === 'bower') {
+        var defaultBowerDir = 'bower_components';
+        var bowerrcPath = sysPath.join(root, '.bowerrc');
+
+        fs.exists(bowerrcPath, function(hasBowerrc) {
+            if (hasBowerrc) {
+                fs.readFile(bowerrcPath, 'utf8', function(error, bowerrcContent) {
+                    if (error) return callback(error);
+
+                    var bowerrcJson = JSON.parse(removeComments(bowerrcContent));
+                    var bowerrcDirectory = bowerrcJson.directory;
+                    callback(null, bowerrcDirectory || defaultBowerDir);
+                });
+            } else {
+                callback(null, defaultBowerDir);
+            }
+        });
+    } else if (type === 'component') {
+        return callback(null, 'components');
+    } else {
+        return callback(null);
+    }
+}
+
+// Return unique list items.
+function unique(list) {
+    return Object.keys(list.reduce(function(obj, _) {
+        if (!obj[_]) obj[_] = true;
+        return obj;
+    }, {}));
+}
+
+function sanitizeRepo(repo) {
+    if (repo.indexOf('/') !== repo.lastIndexOf('/')) {
+        var res = repo.split('/');
+        return res[res.length - 1] + '=' + res[res.length];
+    }
+    return repo.replace('/', '-');
+}
+
+function readJson(file, type, callback) {
+    fs.exists(file, function(exists) {
+        if (!exists) {
+            var err = new Error('Component must have "' + file + '"');
+            err.code = 'NO_' + type.toUpperCase() + '_JSON';
+            return callback(err);
+        }
+
+        fs.readFile(file, function(err, contents) {
+            if (err) return callback(err);
+            contents = contents.toString();
+
+            var json;
+
+            try {
+                json = JSON.parse(removeComments(contents));
+            } catch (err) {
+                err.code = 'EMALFORMED';
+                return callback(new Error('Component JSON file is invalid in "' + file + '": ' + err));
+            }
+
+            callback(null, json);
+        });
+    });
+}
+
+function getJsonPath(path, type) {
+    return sysPath.resolve(sysPath.join(path, jsonPaths[type]));
+}
+
+// Coerce data.main, data.scripts and data.styles to Array.
+function standardizePackage(data) {
+    if (data.main && !Array.isArray(data.main)) data.main = [data.main];
+    jsonProps.forEach(function(_) {
+        if (!data[_]) data[_] = [];
+    });
+    return data;
+}
+
+var getPackageFiles = exports.getPackageFiles = function(pkg) {
+    var list = [];
+    jsonProps.forEach(function(property) {
+        if (Array.isArray(pkg[property])) {
+            list.push.apply(list, pkg[property]);
+        }
+    });
+    return unique(list);
+};
+
+function processPackage(type, pkg, callback) {
+    var path = pkg.path;
+    var overrides = pkg.overrides;
+    var fullPath = getJsonPath(path, type);
+    var dotpath = getJsonPath(path, 'dotbower');
+
+    function _read(actualPath) {
+        readJson(actualPath, type, function(error, json) {
+
+            if (error) return callback(error);
+            if (overrides) {
+                Object.keys(overrides).forEach(function(key) {
+                    json[key] = overrides[key];
+                });
+            }
+
+            if (type === 'bower' && !json.main) {
+                return callback(new Error('Component JSON file "' + actualPath + '" must have `main` property. See https://github.com/paulmillr/read-components#README'));
+            }
+
+            var pkg = standardizePackage(json);
+
+
+            var files = getPackageFiles(pkg).map(function(relativePath) {
+                return sysPath.join(path, relativePath);
+            });
+
+            callback(null, {
+                name: pkg.name,
+                version: pkg.version,
+                exports: pkg.exports,
+                umd: pkg.umd,
+                ignored: pkg.ignored,
+                paths: pkg.paths,
+                repo: sysPath.basename(path),
+                files: files,
+                dependencies: pkg.dependencies || {}
+            });
+        });
+    }
+    fs.exists(dotpath, function(isStableBower) {
+        _read(isStableBower ? dotpath : fullPath);
+    });
+}
+
+function gatherDeps(packages, type) {
+    return Object.keys(packages.reduce(function(obj, item) {
+        if (!obj[item[dependencyLocator[type]]]) obj[item[dependencyLocator[type]]] = true;
+        Object.keys(item.dependencies).forEach(function(dep) {
+            dep = sanitizeRepo(dep);
+            if (!obj[dep]) obj[dep] = true;
+        });
+        return obj;
+    }, {}));
+}
+
+function readPackages(root, type, allProcessed, list, overrides, callback) {
+    getDir(root, type, function(error, dir) {
+        if (error) return callback(error);
+
+        var parent = sysPath.join(root, dir);
+        var paths = list.map(function(item) {
+            if (type === 'component') item = sanitizeRepo(item);
+            return {
+                path: sysPath.join(parent, item),
+                overrides: overrides[item]
+            };
+        });
+
+        each(paths, processPackage.bind(null, type), function(error, newProcessed) {
+            if (error) return callback(error);
+            var processed = allProcessed.concat(newProcessed);
+
+            var processedNames = {};
+            processed.forEach(function(_) {
+                processedNames[_[dependencyLocator[type]]] = true;
+            });
+
+            var newDeps = gatherDeps(newProcessed, type).filter(function(item) {
+                return !processedNames[item];
+            });
+
+            if (newDeps.length === 0) {
+                callback(error, processed);
+            } else {
+                readPackages(root, type, processed, newDeps, overrides, callback);
+            }
+        });
+    });
+}
+
+// Find an item in list.
+function find(list, predicate) {
+    for (var i = 0, length = list.length, item; i < length; i++) {
+        item = list[i];
+        if (predicate(item)) return item;
+    }
+}
+
+// Iterate recursively over each dependency and increase level
+// on each iteration.
+function setSortingLevels(packages, type) {
+    packages.forEach(setLevel.bind(null, 1));
+    return packages;
+
+    function setLevel(initial, pkg) {
+        var level = Math.max(pkg.sortingLevel || 0, initial);
+        var deps = Object.keys(pkg.dependencies);
+        // console.log('setLevel', pkg.name, level);
+        pkg.sortingLevel = level;
+        deps.forEach(function(depName) {
+            depName = sanitizeRepo(depName);
+            var dep = find(packages, function(_) {
+                if (type === 'component') {
+                    var repo = _[dependencyLocator[type]];
+                    if (repo === depName)
+                        return true;
+                    // nasty hack to ensure component repo ends with the specified repo
+                    // e.g. "repo": "https://raw.github.com/component/typeof"
+                    var suffix = '/' + depName;
+                    return repo.indexOf(suffix, repo.length - suffix.length) !== -1;
+                } else {
+                    return _[dependencyLocator[type]] === depName;
+                }
+            });
+
+            if (!dep) {
+                var names = Object.keys(packages).map(function(_) {
+                    return packages[_].name;
+                }).join(', ');
+                throw new Error('Dependency "' + depName + '" is not present in the list of deps [' + names + ']. Specify correct dependency in ' + type + '.json or contact package author.');
+            }
+            setLevel(initial + 1, dep);
+        });
+    }
+}
+
+// Sort packages automatically, bas'component'ed on their dependencies.
+function sortPackages(packages, type) {
+    return setSortingLevels(packages, type).sort(function(a, b) {
+        return b.sortingLevel - a.sortingLevel;
+    });
+}
+
+function init(directory, type, callback) {
+    readJson(sysPath.join(directory, jsonPaths[type]), type, callback);
+}
+
+
+function readComponents(directory, callback, type) {
+    if (typeof directory === 'function') {
+        callback = directory;
+        directory = null;
+    }
+    if (directory === null) directory = '.';
+
+    init(directory, type, function(error, json) {
+        if (error) {
+            if (error.code === 'NO_' + type.toUpperCase() + '_JSON') {
+                return callback(null, []);
+            } else {
+                return callback(error);
+            }
+        }
+
+        var deps = Object.keys(json.dependencies || {});
+        var overrides = json.overrides || {};
+
+        readPackages(directory, type, [], deps, overrides, function(error, data) {
+            if (error) return callback(error);
+            var sorted = sortPackages(data, type),
+                builder,
+                aliases = [];
+            if (type === 'component') {
+                builder = new Builder(directory);
+                emitter.on('addAlias', function(alias) {
+                    aliases.push(alias);
+                });
+                builder.buildAliases(function(err, res) {
+                    callback(null, sorted, aliases);
+                });
+            } else
+                callback(null, sorted);
+        });
+    });
+}
+
+function read(root, type, callback) {
+    if (type === 'bower') {
+        readComponents(root, callback, type);
+    } else if (type === 'component') {
+        readComponents(root, callback, type);
+    } else {
+        throw new Error('read-components: unknown type');
+    }
+}
+
+module.exports = read;
\ No newline at end of file
diff --git a/utils/remove-comments.js b/utils/remove-comments.js
new file mode 100644
index 0000000..8d0c7ce
--- /dev/null
+++ b/utils/remove-comments.js
@@ -0,0 +1,56 @@
+'use strict';
+
+module.exports = removeComments;
+
+var SYMBOLS = {
+    LINE_COMMENT: '//',
+    BLOCK_COMMENT_START: '/*',
+    BLOCK_COMMENT_END: '*/',
+    DOUBLE_QUOTE: '"',
+    NEW_LINE: /\r?\n/
+};
+
+function removeComments(str) {
+    var quoting = false,
+        lineCommenting = false,
+        blockCommenting = false;
+    return str.replace(/\/\/|\/\*|\*\/|"|\r?\n|./g, function(match, index, str) {
+        switch (match) {
+            case SYMBOLS.DOUBLE_QUOTE:
+                if (lineCommenting || blockCommenting) {
+                    return '';
+                }
+                quoting = !quoting;
+                return match;
+            case SYMBOLS.LINE_COMMENT:
+                if (quoting) {
+                    return match;
+                } else if (!blockCommenting) {
+                    lineCommenting = true;
+                }
+                return '';
+            case SYMBOLS.BLOCK_COMMENT_START:
+                if (quoting) {
+                    return match;
+                } else if (!lineCommenting) {
+                    blockCommenting = true;
+                }
+                return '';
+            case SYMBOLS.BLOCK_COMMENT_END:
+                if (blockCommenting) {
+                    blockCommenting = false;
+                    return '';
+                }
+                return match;
+            default:
+                if (lineCommenting && SYMBOLS.NEW_LINE.test(match)) {
+                    lineCommenting = false;
+                } else if (quoting && SYMBOLS.NEW_LINE.test(match)) {
+                    quoting = false;
+                } else if (lineCommenting || blockCommenting) {
+                    return '';
+                }
+                return match;
+        }
+    });
+};
\ No newline at end of file
-- 
2.6.2.windows.1

